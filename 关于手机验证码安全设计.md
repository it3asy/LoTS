
# 关于手机验证码安全设计


2018/09/07

背景是为某Web项目进行安全检测后发现存在手机验证码暴力猜解漏洞，后续修复也不彻底，所以后来和其开发人员对手机验证码暴力猜解问题进行了一次针对性交流，本文是为此交流准备的一个材料。材料中所举的案例和目标Web项目的机制大体相同，换言之，这是为特定场景准备的特定材料，不具有普遍性。 

---


## 0x1 手机验证码的常见安全问题


[1] [短信验证码的常见安全问题](https://www.cnblogs.com/xiaozi/p/7691344.html)  

[2] [谈谈我是如何正确使用验证码](https://www.secpulse.com/archives/47896.html)

手机验证码常见的安全问题以及正确的设计思路，上面的文章基本都有提到。本文只谈谈防止短信验证码暴力猜解的问题。



## 0x2 关于短信验证码暴力猜解

短信验证码暴力猜解基本原理：当服务端不限制验证码出错次数，则攻击者可以通过多次提交来碰撞验证码。比如当前使用4位数字验证码:  

1）如果服务端未限制连续验证错误次数，则攻击者可以尝试从0000到9999所有10000个可能验证码，总有一次会验证成功。**所以必须要限制同一手机号连续验证错误次数。**  

2）如果服务端限制了连续出错次数，10次出错后销毁该验证码。那么攻击者有10次提交验证码的机会，攻击成功的概率是10/10000。（实际中我们可以使用6位验证码，并限制错误次数为3来降低这个概率。）  
这样看似安全，但如果服务端没有限制同一手机号某一段时间内生成验证码的次数，那么攻击者在10次失败后重新生成验证码继续尝试10次验证……这样进行多轮攻击，虽然每轮攻击的成功率是1/1000，但多轮次攻击会使成功率会大增。**所以必须要限制同一手机号在一段时间内生成验证码的次数。**（比如同一手机号间隔2分钟才能再次生成验证码，并且一天内只能生成10次。）    

限制手机验证码暴力猜解有多种针对机制，比如使用图形验证码限制客户端提交频率，比如在后端逻辑中实现验证码失效机制。具体这些机制如何实现，如何避免实现时出差错，这里通过一个案例对此进行探讨。  



## 0x3 案例分析

以下是某个用户注册功能短信验证码部分的实现逻辑（示例代码是从某个JavaWeb项目提取简化，代码为伪代码，比如 `return ("请求频繁稍后再试")` 表示进入一个这样的逻辑，不是说这里就是这样一行代码）。

---begin---  

服务端收到发送短信验证码的请求后生成验证码并存储在数据库中:    

	+----+---------------------+-------+---------------------+-------------+
	| id | createDate          | value | expire              | mobile      |
	+----+---------------------+-------+---------------------+-------------+
	| 20 | 2018-07-23 13:56:57 | 4337  | 2018-07-23 14:56:57 | 150******** |
	| 21 | 2018-07-06 18:38:27 | 4860  | 2018-07-06 19:38:27 | 150******** |
	| 22 | 2018-07-02 11:56:05 | 3523  | 2018-07-02 12:56:05 | 183******** |
	| 23 | 2018-07-02 13:39:09 | 3544  | 2018-07-02 14:39:09 | 183******** |
	| 24 | 2018-07-12 18:40:19 | 5057  | 2018-07-12 19:40:19 | 183******** |
	+----+---------------------+-------+---------------------+-------------+

服务端发送验证码逻辑：  
	
    String phone = getPara("registerphone");
    if (getSession().getAttribute(mobile) != null) {
      time = new Date().getTime() - getSession().getAttribute(phone);
      if (time < 60s) {
        return ("请求频繁稍后再试");   
      }
    }else{
		sendCode(phone);
		getSession().setAttribute(mobile, String.valueOf(new Date().getTime()));
	}


服务端的验证逻辑：  


    String phone = getPara("registerphone");
    String code = getPara("registeryzm");

    //根据手机从数据库查询最后一条验证码记录
    SafeKey safeKey = ((SafeKey)new SafeKey().dao()).findKeyByMobile(phone);

    //查询手机号是否已被使用
    Member pMember = ((Member)new Member().dao()).findUserByMobile(phone);

    if (pMember != null) {
		return "用户已存在!";
    } 

    elif ((null != safeKey) {
		//验证提交的短信验证码是否正确
		if (!(safeKey.getValue().trim().equals(code)))) {
	    	return ("请输入正确的验证码");
	    }

		else{
			//验证通过;
		}
	}

---end---

在这个案例中：  

### 1. 验证码过期问题

虽然数据库设计了expire（过期）字段，但代码中没有较验验证码是否已经过期失效。应当在 `验证短信验证码是否正确` 前较难其是否过期，以下是一个实现逻辑参考：  

		//验证码是否过期
		if (is_expired(safeKey.getExpire()) {
			return ("验证码已过期");
		}
		//验证提交的短信验证码是否正确
		if (!(safeKey.getValue().trim().equals(code)))) {
        	return ("请输入正确的验证码"));
        }

### 验证码出错次数限制问题

没有限制验证码错误次数，应当增加此机制。以下是一个参考实现方案：  

	/* 
	在数据库中新增一个字段failTimes，初始值为0，每失败一次加1，
	当failTimes超过3认为该验证码失效。
	*/

	//验证码失败次数
	int failTimes = safeKey.getFailtimes();
	if (failTimes >= FAILURE_LIMIT) { //FAILURE_LIMIT = 3
		return ("连续出错超过3次，请重新获取验证码");
	}
	//验证提交的短信验证码是否正确
	if (!(safeKey.getValue().trim().equals(code)))) {
		failTimes += 1;
		safeKey.setFailTimes(failTimes);
		safeKey.update(); //更新failTimes字段;
		return ("请输入正确的验证码"));
	}



### 3. 验证码发送频率限制问题

在服务端发送验证码逻辑中，使用Session来存储验证码生成时间，客户端再请求发送验证码的时候同Session中的时间对比，判断间隔时间是否超过60秒。 
 
这个设计看似合理，但其实这个限制是可被绕过的。由于HTTP协议是无状态的，所以Session需要客户端提交的SessionID来判断不同请求是否为同一会话。那么，如果客户端不提交SessionID，服务端的判断机制便失效了。

如果客户端是正常的浏览器操作，浏览器在第一次请求时，服务器会返回一个SesssionID。此后浏览器会在Cookie中带上此SessionID，只要服务端不刷新SessionID，浏览器后续请求都会使用这个SessionID，服务器通过这个SessionID判断这些请求都是同一会话，使用同一Session对象。

那么一个攻击者向服务端连续两次请求发送验证码，而这两次请求中不使用相同的SessionID。服务端收到第一次请求时创建验证码并把创建时间保存在当前Session中。服务端收到第二次请求时去从当前Session中取值，由于两次请求是不同的Session，所以获取不到第一次请求创建的Session值，这个限制逻辑便失效了。

合理设计建议：使用数据库而非Session来实现此限制逻辑。  



## 0x4 小结
 
一般手机验证码服务端有两部分逻辑，一是发送验证码，二是验证码验证。关于防止手机验证码暴力猜解，这两块都要考虑。对于发送验证码部分，需要限制同一手机在时间段内的生成验证码的次数；对于验证验证码部分，需要限制同一验证码失败验证次数（可以考虑增加图形验证码）。有几个基本点要做到：  

* 验证码要设置超时时间，到期后要失效；  
* 验证码要设置验证错误的次数，次数达到后要失效（一般3~5次为宜）。  

具体这些机制怎么实现，需要我们结合具体场景来考虑。
